# algorithm_exam
algorithm exam during learning
* * *
### Sort Algorithm 排序算法
---------------------------------------
[1.selectionSort 选择排序 demo](https://github.com/crystalcst/algorithm_exam/blob/master/sort/selectionSort.js)<br/>
(1)算法简介<br/>
选择排序(Selection-sort)是一种简单直观的排序算法。它的工作原理：首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。<br/>
(2)算法描述和实现<br/>
n个记录的直接选择排序可经过n-1趟直接选择排序得到有序结果。具体算法描述如下：
<1>.初始状态：无序区为R[1..n]，有序区为空；<br/>
<2>.第i趟排序(i=1,2,3…n-1)开始时，当前有序区和无序区分别为R[1..i-1]和R(i..n）。该趟排序从当前无序区中-选出关键字最小的记录 R[k]，将它与无序区的第1个记录R交换，使R[1..i]和R[i+1..n)分别变为记录个数增加1个的新有序区和记录个数减少1个的新无序区；<br/>
<3>.n-1趟结束，数组有序化了。<br/>
(3)算法分析<br/>
最佳情况：T(n) = O(n2)<br/>
最差情况：T(n) = O(n2)<br/>
平均情况：T(n) = O(n2)<br/>

[2.insertionSort 插入排序 demo](https://github.com/crystalcst/algorithm_exam/blob/master/sort/insersionSort.js)<br/>
(1)算法简介<br/>
插入排序（Insertion-Sort）的算法描述是一种简单直观的排序算法。它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。插入排序在实现上，通常采用in-place排序（即只需用到O(1)的额外空间的排序），因而在从后向前扫描过程中，需要反复把已排序元素逐步向后挪位，为最新元素提供插入空间。<br/>
(2)算法描述和实现<br/>
一般来说，插入排序都采用in-place在数组上实现。具体算法描述如下：<br/>
<1>.从第一个元素开始，该元素可以认为已经被排序；<br/>
<2>.取出下一个元素，在已经排序的元素序列中从后向前扫描；<br/>
<3>.如果该元素（已排序）大于新元素，将该元素移到下一位置；<br/>
<4>.重复步骤3，直到找到已排序的元素小于或者等于新元素的位置；<br/>
<5>.将新元素插入到该位置后；<br/>
<6>.重复步骤2~5。<br/>
(3)算法分析<br/>
最佳情况：输入数组按升序排列。T(n) = O(n)<br/>
最坏情况：输入数组按降序排列。T(n) = O(n2)<br/>
平均情况：T(n) = O(n2)<br/>

[3.mergeSort 归并排序 demo](https://github.com/crystalcst/algorithm_exam/blob/master/sort/mergeSort.js)<br/>
(1)算法简介<br/>
归并排序是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。归并排序是一种稳定的排序方法。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为2-路归并。<br/>
(2)算法描述和实现<br/>
具体算法描述如下：<br/>
<1>.把长度为n的输入序列分成两个长度为n/2的子序列；<br/>
<2>.对这两个子序列分别采用归并排序；<br/>
<3>.将两个排序好的子序列合并成一个最终的排序序列。<br/>
(3)算法分析<br/>
最佳情况：T(n) = O(n)<br/>
最差情况：T(n) = O(nlogn)<br/>
平均情况：T(n) = O(nlogn)<br/>

[4.bubbleSort 冒泡排序 demo](https://github.com/crystalcst/algorithm_exam/blob/master/sort/bubbleSort.js)<br/>
(1)算法描述<br/>
冒泡排序是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果它们的顺序错误就把它们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。<br/>
(2)算法描述和实现<br/>
具体算法描述如下：<br/>
<1>.比较相邻的元素。如果第一个比第二个大，就交换它们两个；<br/>
<2>.对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样在最后的元素应该会是最大的数；<br/>
<3>.针对所有的元素重复以上的步骤，除了最后一个；<br/>
<4>.重复步骤1~3，直到排序完成。<br/>
最佳情况：T(n) = O(n)<br/>
当输入的数据已经是正序时<br/>
最差情况：T(n) = O(n2)<br/>
当输入的数据是反序时<br/>
平均情况：T(n) = O(n2)<br/>

[5.shellSort 希尔排序 demo](https://github.com/crystalcst/algorithm_exam/blob/master/sort/shellSort.js)<br/>
(1)算法简介<br/>
希尔排序的核心在于间隔序列的设定。既可以提前设定好间隔序列，也可以动态的定义间隔序列。动态定义间隔序列的算法是《算法（第4版》的合著者Robert Sedgewick提出的。<br/>
(2)算法描述和实现<br/>
先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，具体算法描述：<br/>
<1>. 选择一个增量序列t1，t2，…，tk，其中ti>tj，tk=1；<br/>
<2>.按增量序列个数k，对序列进行k 趟排序；<br/>
<3>.每趟排序，根据对应的增量ti，将待排序列分割成若干长度为m 的子序列，分别对各子表进行直接插入排序。仅增量因子为1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。<br/>
<img src="http://jbcdn2.b0.upaiyun.com/2016/09/ef9f6744ceba18ec7e9e1ae15f4f92e1.jpeg">


### Search Algorithm 检索算法
---------------------------------------
一、检索算法概念用途</br>
1、数据查找是最基本的计算机编程任务</br>
2、对计算机存储的数据执行最常见的两种操作是排序和检索，自从计算机产业伊始便是如此；</br>
二、检索算法关键概念定义</br>
1、在列表中查找分为数据有两种方式，顺序查找和二分查找。顺序查找适用于元素随机排列，二分查找用于已排列好的元素。</br>
2、对于查找数据来说最简单的是从给第一个元素开始对列表元素进行查找，直到找到了想要的结果，被成为线性查找，他属于暴力查找的一种。</br>
3、自组织数据：数据的位置并非由程序员在程序执行之前就组织好，而是在程序执行过程中由程序自动组织。80-20原则指对某一数据集执行的80%查找操作都是对其中20%数据元素进行查找。</br>
4、二分查找：每猜一个数字会有三种结果，猜大了猜小了猜对了。</br>
[1.seqSearch 顺序查找+自组织数据 demo](https://github.com/crystalcst/algorithm_exam/blob/master/search/find.js)<br/>
[2.bindSearch 二分查找 demo](https://github.com/crystalcst/algorithm_exam/blob/master/search/bind.js)<br/>

### List 列表
---------------------------------------
(https://github.com/crystalcst/algorithm_exam/blob/master/dataStructure/list.js)</br>
[1.特点]</br>
(1)有序，类似购物清单

### BST 二叉树
---------------------------------------
(https://github.com/crystalcst/algorithm_exam/blob/master/dataStructure/bst.js)</br>
[1.二叉树概念和用途]</br>
1、树是一种非线性的数据结构，分层存储</br>
2、树被用来存储具有层级关系的数据，还被用来存储有序列表</br>
3、二叉树进行查找特别快，为二叉树添加或删除元素也非常快</br>
4、集合中不允许相同成员存在</br>
[2.二叉树关键概念定义]</br>
1、树由一组以边连接的节点组成</br>
2、一颗树最上面的节点成为根节点，如果一个节点下面连接多个节点，那么该节点称为父节点。一个节点可以有0个、1个或多个子节点。没有任何子节点的节点成为叶子节点/br>
3、二叉树是一种特殊的树,子节点个数不超过2个</br>
4、从一个节点走到另一个节点的这一组边称为路径</br>
5、以某种特定顺序访问树中所有的节点称为树的遍历</br>
6、树分为几个层次，根节点是0层，它的子节点是第1层，以此类推。我们定义树的层数就是树的深度。</br>
7、每个节点都有一个与之相关的值，该值有时被称为键</br>
8、一个父节点的两个子节点分别为左节点和右节点，二叉查找树是一种特殊的二叉树，相对较小的值保存在左节点，较大的值保存在右节点，这一特性使得查找效率很高。
[3.二叉树遍历]</br>
1、前序遍历
根->左->右
2、中序遍历
左->根->右
3、后序遍历
左->右->根

### Graph 图
---------------------------------------
(https://github.com/crystalcst/algorithm_exam/blob/master/dataStructure/graph.js)</br>
[1.图概念和用途]</br>
1、讨论如何给网络建模</br>
2、计算机技术（如互联网）和社会理论（如“六度空间理论”引爆的社交网络）再度把人们的目光吸引到网络研究上</br>
3、看中国地图就是一种图，每个城市都由某种道路相连。</br>
4、二叉树表现相当固定，图的结构却要灵活，一个顶点既可以有一条边，也可以有多条边与它相连。</br>
[2.图关键概念定义]</br>
1、图由边的集合及顶点的集合组成。每一个城市就是一个顶点，每一个道路就是一个边。</br>
2、顶点也有权重，称为成本。如果一个图的顶点是有序的，则称为有向图。在对有向图中的顶点排序后，便可以在两个顶点之间绘制一个箭头。有向图表明了顶点的流向。流程图就是一个有向图的例子。</br>
3、如果图是无序的，则称之为无序图或无向图。</br>
4、从一个节点走到另一个节点的这一组边称为路径。路径中所有的顶点都由边连接。路径的长度用路径中第一个顶点到最后一个顶点之间边的数量表示。指向自身的顶点组成的路径称为环，环的长度为0</br>
5、圈是至少有一条边的路径，且路径的第一个顶点和最后一个顶点相同。无论有向图还是无向图只要没有重复的顶点的圈就是一个简单圈，除了第一个和最后一个顶点以外，路径的其他顶点有重复的圈成为平凡圈。</br>
6、如果两个顶点之间有路径，那么这两个顶点之间就是强连通的。如果有向图的所有顶点都是强连通的，那么这个有向图也是强连通的。</br>
[3.图的搜索]</br>
1、深度优先搜索</br>
2、广度优先搜索</br>
查找最短路径：首先找单边路径，其次是两边路径</br>
广度优先搜索的实质就是查找最短路径</br>
